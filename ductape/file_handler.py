import glob
import logging
import os
import shutil
import zipfile
from pathlib import Path

import rich
from rich.progress import track

from ductape.models import CanvasSubmission

log = logging.getLogger()


def cleanup_files(path):
    """Currently just removes __MACOSX folders."""
    macos_folders = glob.glob(f"{path}/**/__MACOSX", recursive=True)
    for f in macos_folders:
        shutil.rmtree(f)


def flatten_folder(destination):
    """Flatten folders containing a single folder."""
    content = os.listdir(destination)
    if len(content) == 1:
        folder = os.path.join(destination, content[0])
        if os.path.isdir(folder):
            log.debug(f"Flattening {folder}")
            for f in os.listdir(folder):
                shutil.move(os.path.join(folder, f), destination)
            os.rmdir(folder)


def get_unique_path(path: Path) -> Path:
    """
    Get a path with a unique stem. If the provided path already exists,
    the returned path will end with an underscore, followed by a number.

    :param path: The desired path.
    :return: The path with an appropriate numbered suffix, if necessary.
    """
    i = 1
    original_stem = path.stem
    original_suffix = path.suffix

    while path.exists():
        try:
            stem, num = original_stem.rsplit("_", 1)
            i = int(num) + 1
            path = path.with_stem(f"{stem}_{i}").with_suffix(original_suffix)
        except (ValueError, IndexError):
            path = path.with_stem(f"{original_stem}_{i}").with_suffix(original_suffix)
            i += 1
    return path


def unzip_canvas_zip(canvas_zip: Path, destination: Path = None, original_name=False) -> Path:
    """
    Unzip the Canvas submission folder and place them in a folder.
    Set `original_name` to `True` to keep student's ZIP file original name.

    :param canvas_zip: Path to ZIP file generated by Canvas
    :param destination: Path to extract the ZIP files.
    :param original_name: Whether to extract into folders with the original ZIP name.
    :return: The location of the unzipped ZIP files.
    """
    if destination is None:
        destination = Path.cwd() / canvas_zip.with_suffix("").name

    if os.path.exists(destination) and not os.path.isdir(destination):
        raise TypeError(f"{destination} is not a directory.")
    destination = get_unique_path(destination)

    with zipfile.ZipFile(canvas_zip, "r") as zf:
        for zip_item in track(
            zf.infolist(), description=f"Extracting [bright_magenta]{canvas_zip.name}[/]"
        ):

            rich.print(f"Extracting [magenta]{zip_item.filename}[/]")
            submission = CanvasSubmission(zip_item.filename)
            stem = submission.original_filename if original_name else submission.canvas_filename

            log.debug(f"Extracting {stem}")

            with zf.open(zip_item, "r") as f:
                try:
                    # If it's a ZIP file, extract it in a folder with that name.
                    path = destination / stem.with_suffix("")
                    with zipfile.ZipFile(f) as student_zip:
                        student_zip.extractall(path)
                    cleanup_files(path)
                    flatten_folder(path)
                except zipfile.BadZipfile:
                    # If not, just place it in the folder.
                    zip_item.filename = stem.name
                    zf.extract(zip_item, destination)

    return destination
