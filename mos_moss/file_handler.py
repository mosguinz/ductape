import glob
import logging
import os
import re
import shutil
import zipfile
from pathlib import Path

LANGUAGE_EXTENSIONS: dict[str, list[str]] = {
    "java": ["java"],
    "cpp": [".cpp", ".h", ".hpp"],
}

log = logging.getLogger()


def cleanup_files(path):
    """Currently just removes __MACOSX folders."""
    macos_folders = glob.glob(f"{path}/**/__MACOSX", recursive=True)
    for f in macos_folders:
        shutil.rmtree(f)


def flatten_folder(destination):
    """Flatten folders containing a single folder."""
    content = os.listdir(destination)
    if len(content) == 1:
        folder = os.path.join(destination, content[0])
        if os.path.isdir(folder):
            log.debug(f"Flattening {folder}")
            for f in os.listdir(folder):
                shutil.move(os.path.join(folder, f), destination)
            os.rmdir(folder)


def unzip_canvas_submission(canvas_zip: Path, zip_output: Path, original_name=False) -> None:
    """
    Unzip the Canvas submission folder and place them in a folder.
    Set `original_name` to `True` to keep student's ZIP file original name.

    :param canvas_zip: Path to ZIP file generated by Canvas
    :param zip_output: Path to extract the ZIP files.
    :param original_name: Whether to extract into folders with the original ZIP name.
    :return: None
    """
    if zip_output is None:
        zip_output = Path.cwd() / canvas_zip.with_suffix("").name

    # If path already exists, first check if we should write to it.
    if os.path.exists(zip_output):
        if not os.path.isdir(zip_output):
            raise TypeError(f"{zip_output} is not a directory.")
        if os.listdir(zip_output):
            raise FileExistsError(f"{zip_output} is not empty.")

    with zipfile.ZipFile(canvas_zip, "r") as zf:
        for submission in zf.infolist():
            # Canvas ZIP name format (may contain -i
            # at the end for resubmissions, where i is the attempt number):
            # <last><first>_<canvas_id>_<sis_id>_<original_filename>[-i]
            res = re.match(r"(\w+_\w*_\d+\d+)_(.+)\.", submission.filename)
            try:
                folder_name = res[2] if original_name else res[1]
            except TypeError:  # if match returns None
                log.warning("Could parse the Canvas ZIP file, did the format change?")
                folder_name = submission.filename

            log.debug(f"Extracting {folder_name}")

            b = zf.open(submission, "r")
            with zipfile.ZipFile(b) as student_zip:
                path = os.path.join(zip_output, folder_name)

                student_zip.extractall(path=path)
                cleanup_files(path)
                flatten_folder(path)


def list_files(folder: str, language="") -> list[str]:
    """
    List files from the provided folder. If `language` is provided, the
    resulting list will only contain files that match the extension of the
    language.
    """
    files = []
    for ext in LANGUAGE_EXTENSIONS.get(language.lower(), ""):
        files += glob.glob(f"{folder}/**/*{ext}", recursive=True)

    new_files = []
    for f in files:
        if (
            os.path.isfile(f)
            and not f.endswith("pdf")
            and not f.endswith("jar")
            and os.path.getsize(f) > 0
        ):
            new_files.append(f)
    return new_files
